"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[231],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>u});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=c(r),g=o,u=h["".concat(s,".").concat(g)]||h[g]||m[g]||a;return r?n.createElement(u,l(l({ref:t},p),{},{components:r})):n.createElement(u,l({ref:t},p))}));function u(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,l=new Array(a);l[0]=g;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[h]="string"==typeof e?e:o,l[1]=i;for(var c=2;c<a;c++)l[c]=r[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}g.displayName="MDXCreateElement"},5503:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var n=r(7462),o=(r(7294),r(3905));const a={},l="Welsh Powell Algorithm",i={unversionedId:"algorithms/coloring/welsh-powell",id:"algorithms/coloring/welsh-powell",title:"Welsh Powell Algorithm",description:"Welsh Powell Algorithm computes a coloring of the vertices of a (simple, connected) graph such that no two adjacent",source:"@site/docs/algorithms/coloring/welsh-powell.md",sourceDirName:"algorithms/coloring",slug:"/algorithms/coloring/welsh-powell",permalink:"/graaf/docs/algorithms/coloring/welsh-powell",draft:!1,editUrl:"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/coloring/welsh-powell.md",tags:[],version:"current",frontMatter:{},sidebar:"algorithmSidebar",previous:{title:"Greedy Graph Coloring Algorithm",permalink:"/graaf/docs/algorithms/coloring/greedy-graph-coloring"},next:{title:"Cycle Detection Algorithms",permalink:"/graaf/docs/category/cycle-detection-algorithms"}},s={},c=[{value:"Syntax",id:"syntax",level:2}],p={toc:c},h="wrapper";function m(e){let{components:t,...r}=e;return(0,o.kt)(h,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"welsh-powell-algorithm"},"Welsh Powell Algorithm"),(0,o.kt)("p",null,"Welsh Powell Algorithm computes a coloring of the vertices of a (simple, connected) graph such that no two adjacent\nvertices have the same color."),(0,o.kt)("p",null,"If the graph has different connected components, each component will be treated as a separate simple connected graph."),(0,o.kt)("p",null,"The algorithm is heuristic and does not guarantee an optimal number of different colors (that is, equal to the chromatic\nnumber of a simple, connected graph)."),(0,o.kt)("p",null,"Colors are represented by the numbers 0, 1, 2,... The Welsh Powell algorithm considers the vertices of the graph in\ndescending order of their degrees and assigns each vertex with its first available color, i.e. the color with the\nsmallest number that is not already used by one of its neighbors."),(0,o.kt)("p",null,"The overall worst-case time complexity of the algorithm is ",(0,o.kt)("inlineCode",{parentName:"p"},"O(n^2)"),". In cases where the graph has a fixed degree (a\nconstant number of neighbors for each vertex), the time complexity can be approximated as ",(0,o.kt)("inlineCode",{parentName:"p"},"O(n)"),". However, if the graph\nis highly connected (dense) and approaches a complete graph, the time complexity could approach ",(0,o.kt)("inlineCode",{parentName:"p"},"O(n^2)"),"."),(0,o.kt)("p",null,"If no coloring is possible, an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"unordered_map")," is returned. This is the case when the graph contains no vertices."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.tutorialspoint.com/welsh-powell-graph-colouring-algorithm"},"Tutorials Point")),(0,o.kt)("h2",{id:"syntax"},"Syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename GRAPH>\nstd::unordered_map<vertex_id_t, int> welsh_powell_coloring(const GRAPH& graph);\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"graph")," A graph to perform graph coloring on."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"return")," An unordered_map where keys are vertex identifiers and values are their respective colors. If no coloring\nis possible, an empty ",(0,o.kt)("inlineCode",{parentName:"li"},"unordered_map")," is returned.")))}m.isMDXComponent=!0}}]);